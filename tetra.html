<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three.js Tetrahedron Data Grid</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
    <script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.160.0/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
				}
			}
		</script>
</head>
<body>
    <!-- Import Three.js library from a CDN -->

    <script type="module">
        import * as THREE from 'three';

        // --- Setup Basic Three.js Scene ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        camera.position.z = 20;

        // Add some basic lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 2); // soft white light
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // --- Data Generation ---
        const dataArray = Array.from({ length: 200 }, (_, i) => i + 1);
        const itemsPerFace = 15; // We'll fit 15 items per face (corresponds to a 5-row triangle)

        // --- Core Functionality: Mapping 2D points to 3D space using interpolation ---

        function get3DPosition(v1, v2, v3, u, v) {
            const point = new THREE.Vector3();
            point.lerpVectors(v1, v2, u); // Point on base edge (V1-V2)
            point.lerp(v3, v);            // Interpolate towards top vertex (V3)
            return point;
        }

        function createDataPointsOnTetrahedron() {
            const radius = 8;
            const geometry = new THREE.TetrahedronGeometry(radius, 0);
            const vertices = geometry.attributes.position.array;
            
            const faceVertices = [
                [2, 1, 0], [0, 3, 2], [1, 3, 0], [2, 3, 1] 
            ];
            
            // Distribute data evenly across 4 faces
            const itemsPerFace = Math.ceil(dataArray.length / 4);

            for (let faceId = 0; faceId < 4; faceId++) {
                const V1 = new THREE.Vector3(vertices[faceVertices[faceId][0]*3], vertices[faceVertices[faceId][0]*3+1], vertices[faceVertices[faceId][0]*3+2]);
                const V2 = new THREE.Vector3(vertices[faceVertices[faceId][1]*3], vertices[faceVertices[faceId][1]*3+1], vertices[faceVertices[faceId][1]*3+2]);
                const V3 = new THREE.Vector3(vertices[faceVertices[faceId][2]*3], vertices[faceVertices[faceId][2]*3+1], vertices[faceVertices[faceId][2]*3+2]);

                // Slice data for this face
                const start = faceId * itemsPerFace;
                const end = Math.min(start + itemsPerFace, dataArray.length);
                const faceData = dataArray.slice(start, end);
                
                if (faceData.length === 0) continue;

                // Calculate total rows needed for this specific amount of data
                // Pattern: 1, 1, 2, 2, 3, 3...
                let count = 0;
                let totalRows = 0;
                let r_calc = 1;
                while (count < faceData.length) {
                    count += Math.ceil(r_calc / 2);
                    totalRows = r_calc;
                    r_calc++;
                }

                let dataIndex = 0;
                let r = 1;
                while (dataIndex < faceData.length) {
                    const itemsInRow = Math.ceil(r / 2);
                    
                    // Vertical position v (1 at top V3, 0 at bottom V1-V2)
                    const v = 1 - (r / (totalRows + 1));

                    for (let c = 0; c < itemsInRow; c++) {
                        if (dataIndex >= faceData.length) break;

                        // Horizontal position u (0 to 1 along the horizontal slice)
                        const u = (c + 0.5) / itemsInRow;

                        const position = get3DPosition(V1, V2, V3, u, v);

                        // Create visual sphere
                        const sphereGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                        const material = new THREE.MeshStandardMaterial({ color: 0x0077ff });
                        const sphere = new THREE.Mesh(sphereGeometry, material);
                        
                        sphere.position.copy(position);
                        scene.add(sphere);

                        dataIndex++;
                    }
                    r++;
                }
            }
        }

        createDataPointsOnTetrahedron();

        // Optional: Add the underlying tetrahedron mesh (slightly transparent)
        const tetraGeometry = new THREE.TetrahedronGeometry(8, 0);
        const tetraMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xcccccc, 
            transparent: true, 
            opacity: 0.2,
            wireframe: true // Makes the structure clear
        });
        const tetrahedronMesh = new THREE.Mesh(tetraGeometry, tetraMaterial);
        scene.add(tetrahedronMesh);


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            // Rotate the tetrahedron so we can see all faces
            scene.rotation.x += 0.001;
            scene.rotation.y += 0.005;
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
